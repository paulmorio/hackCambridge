{
    "beaker": "2",
    "evaluators": [
        {
            "name": "HTML",
            "plugin": "HTML",
            "view": {
                "cm": {
                    "mode": "htmlmixed"
                }
            }
        },
        {
            "name": "TeX",
            "plugin": "TeX",
            "view": {
                "cm": {
                    "mode": "stex"
                }
            }
        },
        {
            "name": "JavaScript",
            "plugin": "JavaScript",
            "view": {
                "cm": {
                    "mode": "javascript",
                    "background": "#FFE0F0"
                }
            }
        },
        {
            "name": "IPython",
            "plugin": "IPython",
            "imports": "",
            "supplementalClassPath": "",
            "setup": "%matplotlib inline\nimport numpy\nimport matplotlib\nfrom matplotlib import pylab, mlab, pyplot\nnp = numpy\nplt = pyplot\nfrom IPython.display import display\nfrom IPython.core.pylabtools import figsize, getfigs\nfrom pylab import *\nfrom numpy import *\n",
            "view": {
                "cm": {
                    "mode": "python"
                }
            }
        }
    ],
    "cells": [
        {
            "id": "markdownmqLpeS",
            "type": "markdown",
            "body": [
                "# A Small Research Hack from HackCambridge: Detecting and Visualising Clusterings in Protein Interaction Networks (And a few other cool things like Facebook)",
                "By Paul Scherer (paulmorio)",
                "",
                "## Summary",
                "",
                "For my submission to HackCambridge I wanted to spend my 24 hours learning something new in accordance with my interests. I was recently introduced to protein interaction networks in my Bioinfomartics class, and during my review",
                "of machine learning techniques for an exam noticed that we study many supervised methods, but no unsupervised methods other than the k means clustering. Thus I decided to combine the two interests by clustering the Protein ",
                "interaction networks with unsupervised clustering techniques and communicate my learning, results, and visualisations using the Beaker notebook. ",
                "",
                "The study of protein-protein interactions (PPIs) determined by high-throughput experimental techniques has created karge sets of interaction data  and a new need for methods allowing us to discover new information ",
                "about biological function. ",
                "These interactions can be thought of as a large-scale network, with nodes representing proteins and edges signifying an interaction between two proteins. In a PPI network, we can ",
                "potentially find protein complexes or functional modules as densely connected subgraphs. A protein complex is a group of proteins that interact with each other at the same time and place creating a quaternary structure. ",
                "Functional modules are composed of proteins that bind each other at different times and places and are involved in the same cellular process. Various graph clustering algorithms have been applied to PPI networks to ",
                "detect protein complexes or functional modules, including several designed specifically for PPI network analysis. A select few of the most famous and recent topographical clustering algorithms were implemented based on descriptions ",
                "from papers, and applied to PPI networks. Upon completion it was recognized that it is possible to apply these to other interaction networks like friend groups on social networks, site maps, or transportation networks to name a few.",
                "",
                "I decided to Graphistry's GPU cluster to visualize the large networks with the kind permission of Dr. Meyerovich. (Otherwise I would have likely not finished on time given the specs of my machine) and communicate my results",
                "and learning process",
                "",
                "## WHO FOR?",
                "**EVERYONE** but mainly myself as I was curious about other PPI networks having been introduced to them in my Bioinformatics class, and unsupervised machine learning methods because my university only taught K means clustering. Which",
                "is not applicable to the type of data that does not include a notion of distance as shown here. ",
                "",
                "## WHY?",
                "{PPI networks? **CAUSE** it helps find scientists hyptothesise about the functional nature of our bodies, or pretty much any living organism provided its interactome can be extracted. Moreover it helps us hypothesise about new drugs. ",
                "",
                "Other networks? **CAUSE** it looked like a bit of fun to experiment.",
                "",
                "It also helps you find the people you should be friends with. Look at the Facebook example.",
                "",
                "## Disclaimer (Apologies before hand)",
                "I made this as quick as possible during a period of 15 hours at HackCambridge so I didn't have the time to check all of the facts, refactor the code and make the descriptions of each of the clustering algorithms perfect. Moreover ",
                "I was unable to fix some of the rendering problems of the equations in these boxes within the time frame. All of the tex renders in standard tex packages, if its necessary. ",
                "",
                "If I have missed a citation, made an incorrect statement, or used insufficient citation format, I sincerely apologize this was not intended as a serious publication but one built out of enjoyment at a hackathon. ",
                "",
                "## Known Issues: ",
                "- Rendering the graphs needs WebGL to work on your browser",
                "",
                "## Which ones were made?",
                "- K Clique Percolation",
                "- MCode",
                "- DP Clustering",
                "- IPCA",
                "- CoAch",
                "",
                "## Hack Submission Link on DevPost",
                "http://devpost.com/software/cluster-punk-a-little-exploratory-research"
            ],
            "mode": "preview",
            "evaluatorReader": false
        },
        {
            "id": "markdownDdAD6X",
            "type": "markdown",
            "body": [
                "# Clustering Algorithm: K Clique Percolation",
                "TL;DR. A clique merging algorithm. Given a set $k$, the algorithm goes on to produce $k$ clique clusters and merge them (percolate) as necessary.",
                "",
                "The method of clique percolation was first introduced by Der ́enyi et al. \\cite{derenyi2005} for random graphs and was formally defined by Palla et al. \\cite{Palla2005} (in the supplementary material section). Because it is designed to discover highly dense communities of nodes, clique percolation turned out to be a popular method for protein-complex prediction in PPI networks. As such, several clique percolation algorithms have been proposed, notably CFinder \\cite{adamcsek2006}, sequential clique percolation (SCP) \\cite{kumpula2008}, and most recen tly, a very efficient implementation using a binary tree hierarchy and Bloomfilters \\cite{reid2012}.",
                "",
                "A clique is a completely connected subset of nodes in a graph, or maximally connected subgraph, where an edge exists between every pair of nodes in the subset. The goal of clique percolation is, given a network and some $k$, to find all cliques of size $k$ in the network and build percolation communities from them. Two k cliques percolate into each other if they have (k − 1) vertices in common. Such k cliques can be said to be adjacent to one another, and a k clique is reachable from another k clique if there exists a sequence of adjacent k cliques by which the first clique can be transformed into the second. Percolation communities are formed from the union of maximally reachable k cliques, where every k clique is reachable from every other k clique. To find percolation communities, the CFinder and Bloom filter methods start by discovering maximal cliques (cliques which are not already contained in any larger clique within the given network) and for certain $k$, applying adjacency filtering. CFinder uses a clique to clique overlap matrix to find percolation communities, while the Bloom filter method eliminates non adjacent k cliques in a binary tree hierarchy. In the sequential clique percolation approach, SCP finds all k cliques in the network and percolates based on common size (k − 1) subcliques. The Bloom filter method empirically outperforms the other methods for all values of $k$, and SCP has been found to be most efficient for low $k$. Farkas et al. \\cite{farkas2007} discuss procedures for applying clique intensity in order to adapt the clique percolation method for weighted network analysis. Due to difficulties with the intractability of the CFinder algorithm, and the Bloom Filter's intended use with maximal cliques (which is not suited to generation of all cliques (and thus not appropriate to our tasks of just playing around with these clustering techniques. I chose to implement a weighted version of the SCP algorithm, which naturally generates all cliques of size $k$."
            ],
            "mode": "preview",
            "evaluatorReader": false
        },
        {
            "id": "markdown5Yi3Yk",
            "type": "markdown",
            "body": [
                "# Clustering Algorithm: MCode",
                "TL;DR seed growth approach to finding dense subgraphs",
                "",
                "Introduced by Bader and Hogue in 2003 \\cite{Bader2003}, MCODE is the earliest seed-growth method for predicting protein complexes from PPI networks. MCODE works in by weighing vertices, followed by molecular complex prediction. In the vertex weighting step, the weight of a vertex v in the PPI network is calculated from the highest k-core of v’s neighborhood, including v. The k-core of a graph is a subgraph where every node is of degree k or greater. It is worth noting that the highest k-core is simply the k-core with the highest value of k. The weight of v is defined as this maximum k times the density of the corresponding k-core. In the current implementation of MCODE published online (http://baderlab.org/Software/MCODE), the density of a k-core $C_{k} = (V_{k} , E_{k} )$ is defined as",
                "",
                "$$ d(k) = \\frac{|E_{k}|}{|V_{k}|^{2}}$$",
                "",
                "After all the nodes in the network are weighted, MCODE applies the seed growth procedure to build communities. In this procedure a seed is selected as the highest weighted vertex, and the cluster is recursively grown. The growing is done by including the neighbouring nodes within a user set percentage of the original seed weight known as the vertex weight percentage (VWP). Once the cluster is formed, its vertices are marked as \"used\" or \"visited\", taking them out of the count for any future clusters. This process is repeated until all vertices have been \"used\". There are many post processing techniques that can be applied, however for the sake of time, and precedence for other algorithms, I haven't done so. (Possible bed for future work and improvements). "
            ],
            "mode": "preview",
            "evaluatorReader": false
        },
        {
            "id": "markdown22tbRq",
            "type": "markdown",
            "body": [
                "# Clustering Algorithm: DP Clustering",
                "TL;DR seed growth approach to finding dense subgraphs similar to MCODE but has an internal representation of weights in the edges, and the stopiing condition is different.",
                "",
                "DPClus, defined by Amin et. al in \\cite{altaf2006}, projects weights onto an unweighted graph using a common neighbors approach. In DPClus, the weight of an edge $(u, v) \\in E$ is defined as the number of common neighbors between $u$ and $v$. Similarly, the weight of a vertex is its weighted degree – the sum of all edges connected to the vertex. This algorithm is similar to MCODE intuitively, except the stopping condition for cluster formation is based on cluster density, rather than vertex weight.",
                "",
                "DPClus relies on two stopping thresholds for cluster formation: cluster density $(d_{in} )$ and cluster property $(cp_{in})$. The density $d_{k}$ of a cluster $ C_{k} = (V _{k} , E_{k}) $ is defined as the ratio of the number of edges in the cluster to the number of possible edges in the cluster, or",
                "",
                "$$ d_{k} = \\frac{E_{k}}{|V_{k}| * (|V_{k}| - 1)}$$",
                "",
                "The cluster property $cp_{nk}$ between a node $n$ and a cluster $C_{k}$ is defined as the inverse density of $C_{k}$ (without n) weighted by the proportion of cluster nodes which are adjacent to n:",
                "",
                "$$ cp_{nk} = \\frac{|N_{n} \\bigcap V_{k}|}{d_{k} * |V_{k}|} $$",
                "",
                "where $N_{n}$ is the set of vertices adjacent to n. For seed node selection, the seed is chosen as the vertex with the highest weight, unless the highest weight is zero (meaning that no two nodes in the graph share any common neighbours), in which case the vertex with the highest degree is chosen as the seed. The cluster is grown by iteratively selecting the highest priority vertex from its set of neighbour vertices. The priority of a neighbour vertex is determined by 1) the number of cluster nodes adjacent to the neighbour and 2) the sum of the edge weights between the neighbour and its adjacent cluster nodes. Cluster growth stops when no neighbour vertex can be added without either the cluster density (including the neighbour) or the cluster property (between the neighbour and the original cluster) dropping below its respective threshold. At this point, all nodes in the cluster are removed from the network, and the edge and vertex weights of the resulting graph are recalculated. The algorithm terminates when no edges in the graph remain.",
                "",
                "Like MCODE, DPClus does not natively generate overlapping clusters but does allow for overlapping cluster nodes can be added in a post-processing step. To do this, DPClus considers all neighbours of the original cluster, both visited and unvisited. Using this neighbour set, it applies the same iterative prioritize-add-reweight procedure as before, but does not expand the neighbourhood frontier when a neighbour is added to the cluster. That is, only neighbors of the original cluster are considered as candidates for expansion. The method for incorporating edge weights to DPClus affects much of the algorithm. The seed node for a new cluster is simply chosen as the highest global weighted- degree vertex. This weighted degree is computed from the remaining graph, just as in the unweighted version.",
                "",
                "When putting precedence on neighbour vertices, only the first criterion is altered, ordering by: 1) the sum of the global edge weights between the vertex and the cluster node, and 2) the sum of the local edge weights between the vertex and the cluster node. Finally, when determining cluster density with a candidate neighbor vertex included, the general formula for weighted subgraph density is employed using the global edge weights. Local edge and vertex weights of the remaining graph are recalculated every iteration in the exact same manner as before."
            ],
            "mode": "preview",
            "evaluatorReader": false
        },
        {
            "id": "markdown40qMwA",
            "type": "markdown",
            "body": [
                "# Clustering Algorithm: IPCA",
                "TL;DR Modified DPClus Algorithm which focuses on maintaining the diameter of a cluster (defined as the maximum shortest distance between all pairs of vertices, rather than its density.",
                "",
                "IPCA was introduced by Li et. al \\cite{Li2008} as a modified version of DPClus. In contrast to DPClus, this method focuses on the maintaining the diameter of a cluster, defined as the maximum shortest distance between all pairs of vertices, rather than its density. In doing so, the seed growth aspect of IPCA emphasizes structural closeness of a predicted protein complex, as well as structural connectivity. Like DPClus, IPCA computes local vertex and edge weights by counting the number of common neighbours shared between two vertices. However, IPCA calculates these values only once at the beginning of the algorithm, rather than updating them every time a discovered cluster is removed from the graph. This allows overlap to occur naturally between clusters, as cluster nodes are not permanently removed from the graph; however, it can also lead to a large amount of cluster overlap. IPCA can incorporate two different neighbour-ordering thresholds: $(SP \\leq d)$ and $(ASP \\leq d)$. $(SP \\leq d)$ requires that the diameter of a cluster never exceed $d$, while $(ASP \\leq d)$ considers the average length of the shortest paths between all pairs vertices in a cluster. Because the currently published implementation of IPCA only implements $(SP \\leq d)$, we focus on this threshold alone. Seed node selection in IPCA works the same as in DPClus, where the unvisited vertex with the highest weight is chosen, with ties going to the vertex with the highest degree. A cluster K is extended by ordering its neighbors by the value $IN_{v_{K}}$ , defined as ",
                "",
                "$$ IN_{v_{K}} = \\frac{m_{v_{K}}}{|K|} $$",
                "",
                "Where $m_{v_{K}}$ is the number of edges between a neighbor vertex $v$ and the cluster. The highest-valued neighbor $v$ is added to the cluster if it meets two conditions: 1) $IN_{v_{K}} \\geq T_{in}$ , and 2) $SP_{(K + v)} \\leq d$. Here, $T_{in}$ is a user-specified threshold dictating the minimum percentage of adjacent cluster nodes that $v$ must share in order to be added to the cluster. The second condition requires that the maximum shortest path length between $v$ and every member of $K$ be no greater than $d$. Typically, $d$ is set to two. To integrate edge weights to IPCA, the value $IN_{v_{K}}$ subsequently becomes:",
                "",
                "$$ IN_{v_{K}} = \\frac{\\sum{_{u \\in k}}w(u,v)}{|K|} $$",
                "",
                "Importantly, the requirement of IPCA that ${IN}_{v_{K}} \\geq T$ in becomes much more stringent in a weighted network context. If a vertex is chosen as a seed node but has no associated global edge weights greater than $T_{in}$ , no neighbors will be added to the cluster. In this event, the seed node is still marked as visited, but the size-1 cluster is not reported as a predicted protein complex. This greatly reduces the number of clusters reported by the IPCA method. If a neighboring vertex meets both of the above criteria, it is added to the cluster, and the priorities of the neighbours of this new cluster are recalculated. If no such neighbour is found, cluster growth stops, and the cluster is output as a predicted protein complex. The vertices in a generated cluster are marked as visited, making them ineligible as seed nodes but still able to be included in future clusters."
            ],
            "mode": "preview",
            "evaluatorReader": false
        },
        {
            "id": "markdownbjVvoF",
            "type": "markdown",
            "body": [
                "# Clustering Algorithm: CoAch",
                "TL;DR Combined Approach with finding a small number of cliques as complexes first and then growing them. ",
                "",
                "The motivation behind the core-attachment(CoAch) algorithm \\cite{Wu2009} comes from the observation that protein complexes often have a dense core of highly interactive proteins. CoAch works in two steps, first discovering highly connected regions (“preliminary cores”) of a network and then expanding these regions by adding strongly associated neighbours. The algorithm operates with three user specified parameters: minimum core density $d$ (for preliminary cores), maximum core affinity $t$ (similarity threshold for distinct preliminary cores), and minimum neighbour closeness (for attaching non-core neighbours to preliminary cores). Minimum neighbour closeness is typically given as one-half. The first step in CoAch is to discover protein-complex cores. To this end, a set of candidate cores is generated for every vertex in the graph, with similar cores consolidated to be maximally dense. The process for generating candidate cores from a vertex $v$ is as follows: First, the algorithm determines $G_v$ , the 2-core graph of v’s neighbourhood, including $v$. This step removes nodes that have no connections in v’s neighbourhood graph apart from sharing an edge with $v$. Next, the core vertices of $G_{v}$ are selected. This is the set of vertices in $G_{v}$ whose degree is greater than or equal to the average degree of $G_{v}$ . After that, CoAch applies a recursive core removal algorithm to $G_{v}$. This algorithm works by dividing $G_{v}$ into non-core clusters of connected nodes if the density of $G_{v}$ is less than a user-specified density threshold. These clusters are further divided into non-core components until the density threshold is met. Core nodes are recursively added back to the cluster once a sufficiently dense subgraph is found. Once the core-removal algorithm is complete, additional post-processing of the discovered cores is applied to make them maximally dense. This gives us a set of candidate cores generated from $v$. The candidate cores of a single vertex are consolidated into a global set of preliminary cores. To apply this “redundancy filtering” step, every candidate core is scored against every preliminary core using the neighbourhood affinity measure:",
                "",
                "$$ N A(A, B) = \\frac{|V_{A}| \\bigcap |V_{B}|}{|V_{A}| * |V_{B}|} $$",
                "",
                "for some candidate core $A$ and some preliminary core $B$. If the $NA$ score between the candidate core and its most similar preliminary core $B_{max}$ is less than the user-defined affinity threshold, the candidate core is added to the set of preliminary cores. Otherwise, if the density-weighted size of the candidate core $(d_{A} * |V_{A}|)$ is greater than that of $B_{max}$, then the candidate core replaces $B_{max}$ in the set of preliminary cores. After preliminary core discovery has been completed on every vertex, the preliminary cores are expanded into predicted protein complexes. For every preliminary core $C = (V_{C} , E_{C})$, CoAch takes the set of directly adjacent neighbors, $N_{C}$ . Then, the algorithm adds all $v \\in N_{C}$ adjacent to more than half of the vertices in $C$. This measure is also known as the closeness of $v$ to $C$: ",
                "",
                "$$ closeness(v, C) = \\frac{|N_{v}| \\bigcap |V_{c}| }{|V_{c}|}$$",
                "",
                "where $N_{v}$ is the neighbor set of $v$."
            ],
            "mode": "preview",
            "evaluatorReader": false
        },
        {
            "id": "markdownkONKot",
            "type": "markdown",
            "body": [
                "# References",
                "1. Imre Der ́enyi, Gergely Palla, and Tam ́as Vicsek. *Clique percolation in random networks.* Phys. Rev. Lett., 94:160202, Apr 2005",
                "2. Gergely Palla, Imre Derenyi, Illes Farkas, and Tamas Vicsek. *Uncovering the overlapping community structure of complex networks in nature and society*. Nature, 435(7043):814–818, Jun 2005.",
                "3. Balzs Adamcsek, Gergely Palla, Ills J. Farkas, Imre Dernyi, and Tams Vicsek. *Cfinder: locating cliques and overlapping modules in biological networks.* Bioinformatics, 22(8):1021–1023, 2006.",
                "4. Jussi M. Kumpula, Mikko Kivel ̈a, Kimmo Kaski, and Jari Saram ̈aki. *Sequential algorithm for fast clique percolation.* Phys. Rev. E, 78:026109, Aug 2008.",
                "5. Fergal Reid, Aaron F. McDaid, and Neil J. Hurley. *Percolation computation incomplex networks.* CoRR, abs/1205.0038, 2012.",
                "6. Gary D. Bader and Christopher WV Hogue. *An automated method for finding molecular complexes in large protein interaction networks.* BMC Bioinformatics, 4(1):1–27, 2003.",
                "7. Md Altaf-Ul-Amin, Yoko Shinbo, Kenji Mihara, Ken Kurokawa, and Shigehiko Kanaya. *Development and implementation of an algorithm for detection of protein complexes in large interaction networks.* BMC Bioinformatics, 7(1):113,2006.",
                "8. Min Li, Jian-er Chen, Jian-xin Wang, Bin Hu, and Gang Chen. *Modifying the dpclus algorithm for identifying protein complexes based on new topological structures.* BMC Bioinformatics, 9(1):1–16, 2008",
                "9. Min Wu, Xiaoli Li, Chee-Keong Kwoh, and See-Kiong Ng. *A core-attachment based method to detect protein complexes in ppi networks.* BMC Bioinformatics, 10(1):1–16, 2009."
            ],
            "evaluatorReader": false
        },
        {
            "id": "code6HIPet",
            "evaluator": "IPython",
            "type": "code",
            "input": {
                "body": [
                    "import networkx",
                    "import graphistry",
                    "graphistry.register(key='YourApiKey')",
                    ""
                ]
            },
            "output": {
                "result": {
                    "type": "Results",
                    "outputdata": [
                        {
                            "type": "out",
                            "value": "Couldn't import dot_parser, loading of dot files will not be possible.\n"
                        },
                        {
                            "type": "err",
                            "value": "WARNING: Could not contact proxy-labs.graphistry.com. Are you connected to the Internet?\n"
                        }
                    ]
                },
                "selectedType": "Results",
                "state": {},
                "pluginName": "IPython",
                "shellId": "6EFC371D24EB43228391EE276AB5CC13",
                "elapsedTime": 1233,
                "height": 51
            },
            "evaluatorReader": true,
            "lineCount": 4
        },
        {
            "id": "markdownkWfsD3",
            "type": "markdown",
            "body": [
                "# Data Visualisations",
                "",
                "Each of Data Visualisations have been saved onto an Amazon server below each code cell for viewing, if you are unable to run the code. ",
                "",
                "## The PPI network of our favorite beer creating creature: yeast! (not really, this is his brother Sacchoromyces Cerevisiae) [From BioGrid] With MCODE clustering"
            ],
            "mode": "preview",
            "evaluatorReader": false
        },
        {
            "id": "coderfHwOr",
            "evaluator": "IPython",
            "type": "code",
            "input": {
                "body": [
                    "# Unweighted interaction dataset of the Saccharomyces Cerevisiae from BioGrid",
                    "graph = networkx.read_edgelist('/home/morio/workspace/hackCambridge/data/network_ICND_1_wo_weights.txt')",
                    "graphistry.bind(source='src', destination='dst', node='nodeid').plot(graph)"
                ]
            },
            "output": {
                "result": "<div class=\"output_subarea output_html rendered_html\"><iframe id=\"d412bace-9757-4880-8206-1307faaeb063\" style=\"display:none; width:100%; height:500px; border: 1px solid #DDD\">\n                </iframe><script>var p = document.location.protocol;\n                        if(p === \"file:\") {p = \"http:\";}\n                        $(\"#d412bace-9757-4880-8206-1307faaeb063\").attr(\"src\", p + \"//proxy-labs.graphistry.com/graph/graph.html?dataset=PyGraphistry/LTR1O1N3NC&type=vgraph&viztoken=4b71f14788d2e469a185e695a699db3a1981e776&usertag=25c60902-pygraphistry-0.9.17&splashAfter=1454694590&info=true\").show();\n                </script><script>\n            $(\"#d412bace-9757-4880-8206-1307faaeb063\").bind('mousewheel', function(e) {\n                e.preventDefault();\n            });\n        </script></div>",
                "selectedType": "Html",
                "state": {},
                "pluginName": "IPython",
                "shellId": "6EFC371D24EB43228391EE276AB5CC13",
                "elapsedTime": 6418,
                "height": 523
            },
            "evaluatorReader": true,
            "lineCount": 3
        },
        {
            "id": "markdownCl4xfv",
            "type": "markdown",
            "body": [
                "##Saved Instance (Click on the image!)"
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeFF0hId",
            "type": "code",
            "evaluator": "HTML",
            "input": {
                "body": [
                    "<a target=\"_blank\" href=\"http://proxy-labs.graphistry.com/graph/graph.html?dataset=PyGraphistry/YHV8GQCTPY&amp;type=vgraph&amp;viztoken=481b554ee55ca048d0ca57c61faaa9bc88cb8c09&amp;usertag=25c60902-pygraphistry-0.9.17&amp;splashAfter=1454686798&amp;info=true&amp;static=true&amp;contentKey=YHV8GQCTPY_eerf36usor&amp;play=0&amp;center=false&amp;menu=false&amp;goLive=false&amp;left=-3.72e+3&amp;right=4.03e+3&amp;top=-1.72e+3&amp;bottom=1.38e+3\"><img height=\"150\" src=\"https://s3-us-west-1.amazonaws.com/graphistry.data/Static/YHV8GQCTPY_eerf36usor/preview.png\" style=\"min-width: 150px; min-height: 150px; background-color: rgb(51, 51, 57);\"></a>"
                ]
            },
            "output": {
                "state": {},
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Html",
                    "object": "<script>\nvar beaker = bkHelper.getBeakerObject().beakerObj;\n</script>\n<a target=\"_blank\" href=\"http://proxy-labs.graphistry.com/graph/graph.html?dataset=PyGraphistry/YHV8GQCTPY&amp;type=vgraph&amp;viztoken=481b554ee55ca048d0ca57c61faaa9bc88cb8c09&amp;usertag=25c60902-pygraphistry-0.9.17&amp;splashAfter=1454686798&amp;info=true&amp;static=true&amp;contentKey=YHV8GQCTPY_eerf36usor&amp;play=0&amp;center=false&amp;menu=false&amp;goLive=false&amp;left=-3.72e+3&amp;right=4.03e+3&amp;top=-1.72e+3&amp;bottom=1.38e+3\"><img height=\"150\" src=\"https://s3-us-west-1.amazonaws.com/graphistry.data/Static/YHV8GQCTPY_eerf36usor/preview.png\" style=\"min-width: 150px; min-height: 150px; background-color: rgb(51, 51, 57);\"></a>"
                },
                "selectedType": "BeakerDisplay",
                "elapsedTime": 0,
                "height": 167
            },
            "evaluatorReader": true,
            "lineCount": 1
        },
        {
            "id": "markdownUvF2q2",
            "type": "markdown",
            "body": [
                "## On Facebook! (from the SNAP database) Example from Graphistry (Clustered on their Algorithm, similar to MCODE)"
            ],
            "mode": "preview",
            "evaluatorReader": false
        },
        {
            "id": "codeFb3av3",
            "evaluator": "IPython",
            "type": "code",
            "input": {
                "body": [
                    "# Facebook friends from the Stanford Network Analysis Project",
                    "graph = networkx.read_edgelist('/home/morio/workspace/hackCambridge/facebook_combined.txt')",
                    "graphistry.bind(source='src', destination='dst', node='nodeid').plot(graph)"
                ]
            },
            "output": {
                "result": "<div class=\"output_subarea output_html rendered_html\"><iframe id=\"8dd5dc1b-f28e-4b4b-9e2b-347076055a19\" style=\"display:none; width:100%; height:500px; border: 1px solid #DDD\">\n                </iframe><script>var p = document.location.protocol;\n                        if(p === \"file:\") {p = \"http:\";}\n                        $(\"#8dd5dc1b-f28e-4b4b-9e2b-347076055a19\").attr(\"src\", p + \"//proxy-labs.graphistry.com/graph/graph.html?dataset=PyGraphistry/X3F86578R4&type=vgraph&viztoken=c2d84e424e2755b66407649073c475bba919ef46&usertag=25c60902-pygraphistry-0.9.17&splashAfter=1454694625&info=true\").show();\n                </script><script>\n            $(\"#8dd5dc1b-f28e-4b4b-9e2b-347076055a19\").bind('mousewheel', function(e) {\n                e.preventDefault();\n            });\n        </script></div>",
                "selectedType": "Html",
                "state": {},
                "height": 523,
                "pluginName": "IPython",
                "shellId": "6EFC371D24EB43228391EE276AB5CC13",
                "elapsedTime": 7069
            },
            "evaluatorReader": true,
            "lineCount": 3
        },
        {
            "id": "markdown1v4qyh",
            "type": "markdown",
            "body": [
                "##Saved Instance (Click on the image!)"
            ],
            "evaluatorReader": false
        },
        {
            "id": "codefFFSTm",
            "type": "code",
            "evaluator": "HTML",
            "input": {
                "body": [
                    "<a target=\"_blank\" href=\"http://proxy-labs.graphistry.com/graph/graph.html?dataset=PyGraphistry/4MG34PETDA&amp;type=vgraph&amp;viztoken=7e90c2b907e44889bb1eb01e415a7495f8d64acd&amp;usertag=25c60902-pygraphistry-0.9.17&amp;splashAfter=1454667733&amp;info=true&amp;static=true&amp;contentKey=4MG34PETDA_cudxhfflxr&amp;play=0&amp;center=false&amp;menu=false&amp;goLive=false&amp;left=-2.93e+4&amp;right=1.33e+4&amp;top=-1.04e+4&amp;bottom=6.68e+3\"><img height=\"150\" src=\"https://s3-us-west-1.amazonaws.com/graphistry.data/Static/4MG34PETDA_cudxhfflxr/preview.png\" style=\"min-width: 150px; min-height: 150px; background-color: rgb(51, 51, 57);\"></a>"
                ]
            },
            "output": {
                "state": {},
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Html",
                    "object": "<script>\nvar beaker = bkHelper.getBeakerObject().beakerObj;\n</script>\n<a target=\"_blank\" href=\"http://proxy-labs.graphistry.com/graph/graph.html?dataset=PyGraphistry/4MG34PETDA&amp;type=vgraph&amp;viztoken=7e90c2b907e44889bb1eb01e415a7495f8d64acd&amp;usertag=25c60902-pygraphistry-0.9.17&amp;splashAfter=1454667733&amp;info=true&amp;static=true&amp;contentKey=4MG34PETDA_cudxhfflxr&amp;play=0&amp;center=false&amp;menu=false&amp;goLive=false&amp;left=-2.93e+4&amp;right=1.33e+4&amp;top=-1.04e+4&amp;bottom=6.68e+3\"><img height=\"150\" src=\"https://s3-us-west-1.amazonaws.com/graphistry.data/Static/4MG34PETDA_cudxhfflxr/preview.png\" style=\"min-width: 150px; min-height: 150px; background-color: rgb(51, 51, 57);\"></a>"
                },
                "selectedType": "BeakerDisplay",
                "elapsedTime": 0,
                "height": 167
            },
            "evaluatorReader": true,
            "lineCount": 1
        },
        {
            "id": "markdownkixLr3",
            "type": "markdown",
            "body": [
                "## Peer to Peer Networks! (Gnutella)"
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeZmv2ZW",
            "type": "code",
            "evaluator": "IPython",
            "input": {
                "body": [
                    "# Small peer to peer network (gnutella) from August 08 2002",
                    "graph = networkx.read_edgelist('/home/morio/workspace/hackCambridge/p2p.txt')",
                    "graphistry.bind(source='src', destination='dst', node='nodeid').plot(graph)"
                ]
            },
            "output": {
                "state": {},
                "result": "<div class=\"output_subarea output_html rendered_html\"><iframe id=\"888785c2-51cb-42af-ab53-e0c93828ef76\" style=\"display:none; width:100%; height:500px; border: 1px solid #DDD\">\n                </iframe><script>var p = document.location.protocol;\n                        if(p === \"file:\") {p = \"http:\";}\n                        $(\"#888785c2-51cb-42af-ab53-e0c93828ef76\").attr(\"src\", p + \"//proxy-labs.graphistry.com/graph/graph.html?dataset=PyGraphistry/50AJTIFW0G&type=vgraph&viztoken=8f6c15b8a9a469d19d8cab7b5ce0420c070061aa&usertag=25c60902-pygraphistry-0.9.17&splashAfter=1454694524&info=true\").show();\n                </script><script>\n            $(\"#888785c2-51cb-42af-ab53-e0c93828ef76\").bind('mousewheel', function(e) {\n                e.preventDefault();\n            });\n        </script></div>",
                "selectedType": "Html",
                "pluginName": "IPython",
                "shellId": "6EFC371D24EB43228391EE276AB5CC13",
                "elapsedTime": 3287,
                "height": 523
            },
            "evaluatorReader": true,
            "lineCount": 3
        },
        {
            "id": "markdowntigNgl",
            "type": "markdown",
            "body": [
                "## Saved Instance (Gnutella)"
            ],
            "evaluatorReader": false
        },
        {
            "id": "code3vr5x3",
            "type": "code",
            "evaluator": "HTML",
            "input": {
                "body": [
                    "<a target=\"_blank\" href=\"http://proxy-labs.graphistry.com/graph/graph.html?dataset=PyGraphistry/50AJTIFW0G&amp;type=vgraph&amp;viztoken=8f6c15b8a9a469d19d8cab7b5ce0420c070061aa&amp;usertag=25c60902-pygraphistry-0.9.17&amp;splashAfter=1454694524&amp;info=true&amp;static=true&amp;contentKey=50AJTIFW0G_8h4cej0pb9&amp;play=0&amp;center=false&amp;menu=false&amp;goLive=false&amp;left=-1.95e+3&amp;right=2.68e+3&amp;top=-864&amp;bottom=984\"><img height=\"150\" src=\"https://s3-us-west-1.amazonaws.com/graphistry.data/Static/50AJTIFW0G_8h4cej0pb9/preview.png\" style=\"min-width: 150px; min-height: 150px; background-color: rgb(51, 51, 57);\"></a>"
                ]
            },
            "output": {
                "state": {},
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Html",
                    "object": "<script>\nvar beaker = bkHelper.getBeakerObject().beakerObj;\n</script>\n<a target=\"_blank\" href=\"http://proxy-labs.graphistry.com/graph/graph.html?dataset=PyGraphistry/50AJTIFW0G&amp;type=vgraph&amp;viztoken=8f6c15b8a9a469d19d8cab7b5ce0420c070061aa&amp;usertag=25c60902-pygraphistry-0.9.17&amp;splashAfter=1454694524&amp;info=true&amp;static=true&amp;contentKey=50AJTIFW0G_8h4cej0pb9&amp;play=0&amp;center=false&amp;menu=false&amp;goLive=false&amp;left=-1.95e+3&amp;right=2.68e+3&amp;top=-864&amp;bottom=984\"><img height=\"150\" src=\"https://s3-us-west-1.amazonaws.com/graphistry.data/Static/50AJTIFW0G_8h4cej0pb9/preview.png\" style=\"min-width: 150px; min-height: 150px; background-color: rgb(51, 51, 57);\"></a>"
                },
                "selectedType": "BeakerDisplay",
                "elapsedTime": 1,
                "height": 167
            },
            "evaluatorReader": true,
            "lineCount": 1
        },
        {
            "id": "markdownRO2lPc",
            "type": "markdown",
            "body": [
                "## Web Graphs! (This is shows off Notre Dame Unis Web Graph!)"
            ],
            "evaluatorReader": false
        },
        {
            "id": "code3J1VVj",
            "type": "code",
            "evaluator": "IPython",
            "input": {
                "body": [
                    "# Notre Dam Uni webgraph from 1999",
                    "graph = networkx.read_edgelist('/home/morio/workspace/hackCambridge/web-NotreDame.txt')",
                    "graphistry.bind(source='src', destination='dst', node='nodeid').plot(graph)"
                ]
            },
            "output": {
                "state": {},
                "result": {
                    "type": "Results",
                    "outputdata": [
                        {
                            "type": "out",
                            "value": "Uploading 5207 kB. This may take a while...\n"
                        },
                        {
                            "type": "err",
                            "value": "WARNING: Large graph: |nodes| + |edges| = 1443292. Layout/rendering might be slow.\n"
                        }
                    ],
                    "payload": "<div class=\"output_subarea output_html rendered_html\"><iframe id=\"457cbedd-7789-46af-b202-f6e27e8960e9\" style=\"display:none; width:100%; height:500px; border: 1px solid #DDD\">\n                </iframe><script>var p = document.location.protocol;\n                        if(p === \"file:\") {p = \"http:\";}\n                        $(\"#457cbedd-7789-46af-b202-f6e27e8960e9\").attr(\"src\", p + \"//proxy-labs.graphistry.com/graph/graph.html?dataset=PyGraphistry/HAWG51AIEC&type=vgraph&viztoken=1d6dedb0020b21147b52e180fd4a285285f95292&usertag=25c60902-pygraphistry-0.9.17&splashAfter=1454693523&info=true\").show();\n                </script><script>\n            $(\"#457cbedd-7789-46af-b202-f6e27e8960e9\").bind('mousewheel', function(e) {\n                e.preventDefault();\n            });\n        </script></div>"
                },
                "selectedType": "Results",
                "pluginName": "IPython",
                "shellId": "DDA1EBAB8ABD430D89CB4D78B79AFC8D",
                "elapsedTime": 140647,
                "height": 557
            },
            "evaluatorReader": true,
            "lineCount": 3
        },
        {
            "id": "markdownTRuDkm",
            "type": "markdown",
            "body": [
                "# Saved Instance (Web Graph)"
            ],
            "evaluatorReader": false
        },
        {
            "id": "codexp7CU0",
            "type": "code",
            "evaluator": "HTML",
            "input": {
                "body": [
                    "<a target=\"_blank\" href=\"http://proxy-labs.graphistry.com/graph/graph.html?dataset=PyGraphistry/HAWG51AIEC&amp;type=vgraph&amp;viztoken=1d6dedb0020b21147b52e180fd4a285285f95292&amp;usertag=25c60902-pygraphistry-0.9.17&amp;splashAfter=1454693523&amp;info=true&amp;static=true&amp;contentKey=HAWG51AIEC_zyqm5nrk9&amp;play=0&amp;center=false&amp;menu=false&amp;goLive=false&amp;left=-3.03e+3&amp;right=4.75e+3&amp;top=-2.77e+3&amp;bottom=340\"><img height=\"150\" src=\"https://s3-us-west-1.amazonaws.com/graphistry.data/Static/HAWG51AIEC_zyqm5nrk9/preview.png\" style=\"min-width: 150px; min-height: 150px; background-color: rgb(51, 51, 57);\"></a>"
                ]
            },
            "output": {
                "state": {},
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Html",
                    "object": "<script>\nvar beaker = bkHelper.getBeakerObject().beakerObj;\n</script>\n<a target=\"_blank\" href=\"http://proxy-labs.graphistry.com/graph/graph.html?dataset=PyGraphistry/HAWG51AIEC&amp;type=vgraph&amp;viztoken=1d6dedb0020b21147b52e180fd4a285285f95292&amp;usertag=25c60902-pygraphistry-0.9.17&amp;splashAfter=1454693523&amp;info=true&amp;static=true&amp;contentKey=HAWG51AIEC_zyqm5nrk9&amp;play=0&amp;center=false&amp;menu=false&amp;goLive=false&amp;left=-3.03e+3&amp;right=4.75e+3&amp;top=-2.77e+3&amp;bottom=340\"><img height=\"150\" src=\"https://s3-us-west-1.amazonaws.com/graphistry.data/Static/HAWG51AIEC_zyqm5nrk9/preview.png\" style=\"min-width: 150px; min-height: 150px; background-color: rgb(51, 51, 57);\"></a>"
                },
                "selectedType": "BeakerDisplay",
                "elapsedTime": 0,
                "height": 167
            },
            "evaluatorReader": true,
            "lineCount": 1
        }
    ],
    "tagMap": {
        "root": [
            "markdownmqLpeS",
            "code6HIPet",
            "markdownDdAD6X",
            "markdown5Yi3Yk",
            "markdown22tbRq",
            "markdown40qMwA",
            "markdownbjVvoF",
            "markdownkWfsD3",
            "coderfHwOr",
            "markdownUvF2q2",
            "codeFb3av3"
        ]
    },
    "tagMap2": {
        "initialization": [],
        "IPython": [
            "markdownmqLpeS",
            "code6HIPet",
            "markdownDdAD6X",
            "markdown5Yi3Yk",
            "markdown22tbRq",
            "markdown40qMwA",
            "markdownbjVvoF",
            "markdownkWfsD3",
            "coderfHwOr",
            "markdownUvF2q2",
            "codeFb3av3"
        ]
    },
    "namespace": {}
}
